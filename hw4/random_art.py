# -*- coding: utf-8 -*-
"""
Created on Tue Feb 11 11:34:57 2014

@author: pruvolo
"""

# you do not have to use these particular modules, but they may help
from random import randint
import Image
from math import sin
from math import cos
from math import pi

def build_random_function(min_depth, max_depth):
    # your doc string goes here
    """Creates a random function, by composing a few basic functions in different ways.  Outputs a list of function names in order from outside to inside.
    """
    
    # your code goes here
    min_depth-=1#   min_depth keeps track of whether the function has recursed the minimum number of times, by subtracting 1 each time the function recurses.  Once min_depth == 0, it has recursed the minimum number of times
    max_depth-=1#   once max_depth ==0, the function has recursed the max number of times
    myfun = list()
    funlist = ["prod", "cos_pi", "sin_pi", "x^3", ".1^x", "x", "y"]
    
    #choose a random function
    #don't choose prod if there are an uneven number of places left
    if max_depth == 1:
        fun = funlist[randint(5,6)]
        return list(fun)
    elif max_depth < 2:# if there are less than two places left don't choose prod
        fun = funlist[randint(1,6)]
    elif min_depth > 0:#    if the min_depth hasn't been reached, don't choose y or x
        fun = funlist[randint(0,4)]
    else:
        fun = funlist[randint(0,6)]
        
    #return
    if fun == 'prod':
        myfun.append(fun)
        #create a list for the first input to prod
        in1 = build_random_function(min_depth-1, max_depth-1)#substract one from mindepth and max depth to account for the other inpout which will be calculated later
        in2 = build_random_function(min_depth-len(in1), max_depth-len(in1))
        min_depth = min_depth - len(in1) - len(in2)
        max_depth = max_depth - len(in1)
        in_all = [in1, in2]
        myfun.append(in_all)
        return myfun
    elif fun =='x' or fun == 'y':
        return list(fun)
    else:#the function only has one input
        myfun.append(fun)
        in_all = build_random_function(min_depth, max_depth)
        myfun.append(in_all)
        return myfun
  #somehow make sure that the depth of both input variables sum to <= maxdepth
  #if fun == prod subtract 2 from max depth, then find an x and a y
    #if fun == x or y add those in ther
    #otherwise find an inside
#
#    if min_depth < 0 and max_depth <= 0:
#        if fun == 'prod' and chance = randint(0,1)#  determines whether the function will recurse again
#        if chance == 1:
#            myfun.append = build_random_function(min_depth, max_depth)
#            return myfun
#        else:
#            return myfun
#    elif min_depth >= 0:
#        myfun = build_random_function(min_depth, max_depth)
#        return myfun
#    else:
#        return myfun
        

def evaluate_random_function(f, x, y):
    # your doc string goes here
    """Evaluate the function returned by build_random_function, using recursion.
    Inputs:
        f   the function generated by build_random_function
        x   value of x at which the function is evaluated
        y   value of y at which the function is evaluated"""
    # your code goes here
    #as you recurse, pass the inputs of the subfunction being evaluated as arguments 
    
    #print f[0]    
    if f[0] == 'x':
        return x
    elif f[0] == 'y':
        return y
    elif f[0] == 'prod':
        return evaluate_random_function(f[1][0], x, y) * evaluate_random_function(f[1][1], x, y)
    elif f[0] == 'sin_pi': 
        return sin(evaluate_random_function(f[1], x, y) * pi)
    elif f[0] == 'cos_pi':
        return cos(evaluate_random_function(f[1], x, y) * pi)
    elif f[0] == 'x^3':        
        return evaluate_random_function(f[1], x, y) ** 3
    elif f[0] == '.1^x':
        return .1 ** evaluate_random_function(f[1], x, y)
    else:
        print("ERROR");
   # elif f[0] == '

    
    

def remap_interval(val, input_interval_start, input_interval_end, output_interval_start, output_interval_end):
    """ Maps the input value that is in the interval [input_interval_start, input_interval_end]
        to the output interval [output_interval_start, output_interval_end].  The mapping
        is an affine one (i.e. output = input*c + b).
    
        Use cross multiplication, comparing the ratios of value - the input interval start to the input range to output value - output interval start to the output range.
        (val-input_interval_start)/(input_interval_start - input_interval_end) = x/(output_interval_start - output_interval_end)
    """
    # your code goes here
    #cross multiplication
    temp = ((input_interval_end-val) * (output_interval_end - output_interval_start)) / (input_interval_end - input_interval_start)
    #print temp
    return temp + output_interval_start
def generate_image():
    """ """
    import pdb
    xpix = 1600
    ypix = 900  
    fun = [build_random_function(1, 3), build_random_function(7,12), build_random_function(2,5)]
    im = Image.new("RGB",(xpix,ypix))
    #im = im_orig.load()
    for yval in range(ypix):
        for xval in range(xpix):
            #pdb.set_trace()
            x = remap_interval(xval, 0., xpix, -1., 1.)
            y = remap_interval(yval, 0., ypix, -1., 1.)
            #print x
            #print y
            #red channel
            Rval = evaluate_random_function(fun[0],x,y)
            #green channel
            Gval = evaluate_random_function(fun[1],x,y)
            #blue channel
            Bval = evaluate_random_function(fun[2],x,y)
            #pdb.set_trace()
            R = int(remap_interval(Rval, -1., 1., 0., 255.))
            G = int(remap_interval(Gval, -1., 1., 0., 255.))
            B = int(remap_interval(Bval, -1., 1., 0., 255.))

            im.putpixel((xval, yval), (R, G, B))
    im.show()
    im.save('desktop3.png')  
generate_image()
#print h
#print evaluate_random_function(h, 1, -1)